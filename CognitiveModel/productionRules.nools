import("types.nools");

function greaterThan(a, b) {
	var ret = (parseFloat(a, 10) > parseFloat(b, 10));
	return ret;
}

function gcd(o, p)
{
	if (o < p) {
		let tmp = o;
		o = p;
		p = tmp;
	}
	var r;
	while (p >= 1) {
		r = o%p;
		o = p;
		p = r
	}	
	return o;
}

function lcm(m, n)
{
	return ((m*n)/gcd(m, n));
}

rule Bootstrap {
	when {
		bool : Boolean bool == false from false;
	}
	then {
		// interface elements first, may help with the order of the hints
		let opt1amt = assert(new TextInput("option1amt", ""));
		let opt1cost = assert(new TextInput("option1cost", ""));
		let opt1end = assert(new TextInput("option1end", ""));
		let opt1button = assert(new RadioButton("option1radio", "option1radio: Option 1", null, "radioGroup"));
		let opt2amt = assert(new TextInput("option2amt", ""));
		let opt2cost = assert(new TextInput("option2cost", ""));
		let opt2end = assert(new TextInput("option2end", ""));
		let opt2button = assert(new RadioButton("option2radio", "option2radio: Option 2", null, "radioGroup"));
		let caIE = assert(new TextInput("commonamt", ""));
		let finalAnswer = assert(new TextInput("finalAnswer", ""));
		let temp = assert(new TextInput("tempcommonamt", ""));
		// let done = assert(new TextInput("done", false));

		// need to add code to create Problem and Options, and to link facts as needed

		// options first
		let values1 = [givenOption1.amount, givenOption1.cost];
		let interfaces1 = ["option1amt", "option1cost", "option1end", "option1radio"];
		let option1 = assert(new Option ("option1", values1, interfaces1)); 

		let values2 = [givenOption2.amount, givenOption2.cost];
		let interfaces2 = ["option2amt", "option2cost", "option2end", "option2radio"];
		let option2 = assert(new Option ("option2", values2, interfaces2)); 
		
		let allOptions = ["option1", "option2"];
		// then problem 
		assert(new Problem("Stub", allOptions,
                unit,
				factor,
				multiple,
				moreBetter,
				caIE.name,
				false));
		
	

		// set start state values in the interface
		assert(new TPA("problemstatement", "UpdateTextArea", probtxt));
		// assert(new TPA("problemequation", "UpdateTextArea", probequ));
		assert(new TPA("optionone", "UpdateTextArea", givenOption1.label));
		assert(new TPA("optiontwo", "UpdateTextArea", givenOption2.label));
		assert(new TPA("itemlabel", "UpdateTextArea", aLabel));
		assert(new TPA("costlabel", "UpdateTextArea", cLabel));
		assert(new TPA("questionone", "UpdateTextArea", q1));
		assert(new TPA("questiontwo", "UpdateTextArea", q2));
		assert(new TPA("questionthree", "UpdateTextArea", q3));
		assert(new TPA("questionthree", "UpdateTextArea", q3));
		assert(new TPA("option1amt", "UpdateTextArea", 90));

		setProblemAttribute("use_backtracking", true);
		setProblemAttribute("prune_old_activations", true);
		halt();
	}
}

/*
ENTER-GIVEN-AMOUNT
IF the amount given in the problem statement for option I is A
And the given amount for option I has not been written
THEN
Write A as the amount for option I
*/


rule EnterGivenAmount {
	
	when {
		p : Problem { options : opts };

			// Now test that opt.name is contained in the Array opts. (Why?) 

		opt : Option opt.name in opts && opt.givenValues && opt.interfaceElements
				{givenValues: givenVals, interfaceElements: ieNames};

			// Now test that ie.name is the first element of the Array ieNames. (Why?) 

		ie : TextInput ie.name == ieNames[0] && !ie.value { name: sel };
	}
	then {
		
		if (checkSAI({selection: sel, action: "UpdateTextField", input: givenVals[0]})) {
			modify(ie, "value", givenVals[0]);
			halt();
		}
		
		if (opt.name == "option1") {
			assert(new Hint(o1ah1));
			assert(new Hint(o1ah2));
		} else {
			assert(new Hint(o2ah1));
			assert(new Hint(o2ah2));		
		}

		assert(new Hint("Enter '"+givenVals[0]+"' in the highlighted input."));
	}
}


/*
ENTER-GIVEN-COST
IF the cost given in the problem statement for option I is C
And the given cost for option I has not been written
THEN
Write C as the cost for option I
*/

rule EnterGivenCost {
	
	when {
		p : Problem { options : opts };

			// Now test that opt.name is contained in the Array opts. (Why?) 

		opt : Option opt.name in opts && opt.givenValues && opt.interfaceElements
				{givenValues: givenVals, interfaceElements: ieNames};

			// Now test that ie.name is the first element of the Array ieNames. (Why?) 

		ie : TextInput ie.name == ieNames[1] && !ie.value { name: sel };
	}
	then {
		
		if (checkSAI({selection: sel, action: "UpdateTextField", input: givenVals[1]})) {
			modify(ie, "value", givenVals[1]);
			halt();
		}
		  // bottom-out hint only

		if (opt.name == "option1") {
			assert(new Hint(o1ch1));
			assert(new Hint(o1ch2));
		} else {
			assert(new Hint(o2ch1));
			assert(new Hint(o2ch2));		
		}
		assert(new Hint("Enter '"+givenVals[1]+"' in the highlighted input."));
	}
}



/*
DETERMINE-COMMON-AMOUNT
IF the amount and cost for both options have been entered
And A1 is the amount for the first option
And A2 is the amount for the second option
And the common amount has not been entered
THEN
Set a subgoal to determine the common amount for amounts A1 and A2
*/


rule DetermineCommonAmount {
	
	when {
		p : Problem { options : opts };
 
		ao1 : TextInput ao1.name == "option1amt" && ao1.value;
		ao2 : TextInput ao2.name == "option2amt" && ao2.value;
		co1 : TextInput co1.name == "option1cost" && co1.value;
		co2 : TextInput co2.name == "option2cost" && co2.value;
		
		ie : TextInput ie.name == "commonamt" && !ie.value { name: sel };
	}
	then {
		if (!unit && !multiple && !factor) {
			assert(new Hint(ch1));
			assert(new Hint(ch2));
		}
		assert(new CommonAmountSubgoal ([ao1.value, ao2.value])); 
		console.log("determine stuff");
		
	}
}

/*
USE-COMMON-MULTIPLE
If there is a subgoal to determine the common amount for amounts A1 and A2
And the problem allows the common multiple strategy
THEN
Write a common multiple of A1 and A2 as the common amount
*/

rule UseCommonMultiple {
	when {
		sg : CommonAmountSubgoal sg.amounts {amounts: a};
		prob: Problem prob.commonMultiple == true && prob.commonAmountIE
			{commonAmountIE: s};
		ie: TextInput ie.name == s;

		//-------- comments ---------
		//Now get the actual student SAI so as to check (in the then-part) if it is
		//    a common multiple of the two amounts.
		//The actual student SAI is stored (by the model tracer) in working memory in the
		//    StudentValues fact.
		//We can access it by matching that fact in the when-part of our rule.
		//We need to make sure we match the right StudentValues fact, since there may be
		//    multiple in working memory;  a new one is added for each step.
		//Therefore, we check the selection slot of the StudentValues slot.
		//However, when we are in a hint cycle, the student SAI does not matter.
		//Therefore, we expand our condition to say that either the student is working on
		// the common ammount step or the student requested a hint.  
		//-------- end comments ---------

		sai: StudentValues sai.selection == s || sai.selection == "hint" {input: i};
	}
	then {
		console.log("Right Here.");
		if (checkSAI({selection: s, action: "UpdateTextField", input: i},
	
				//-------- comments ---------
				// Use a custom comparison function as extra argument to checkSAI,
				//      to check that the student's input is a multiple of
				//      each of the two given amounts.
				// The comparator function will be passed two arguments (by checkSAI): the 
				//      student-generated SAI and the rule-generated SAI, both represented
				//      as Javascript objects.
				// In the current situation, all the comparator function needs is the
				//      actual student inputs.  So it does not need a second argument. 
				//-------- end comments ---------
	
				function(studentSAI) {
					var inputNum = parseInt(studentSAI.input, 10);
					return (inputNum !== 0 && inputNum%a[0] === 0 && inputNum%a[1] === 0);
				}))
		{
			modify(ie, "value", i);
			retract(sg);
			halt();
		}
		assert(new Hint(ch1));
		assert(new Hint(ch2));
		assert(new Hint("Enter '"+lcm(a[0], a[1])+"' in the highlighted input field."));
	}
}


/*
USE-COMMON-FACTOR
If there is a subgoal to determine the common amount for amounts A1 and A2
And the problem allows the common factor strategy
THEN
Write a common factor of A1 and A2 as the common amount
Remove the subgoal
*/


rule UseCommonFactor {
	when {
		sg : CommonAmountSubgoal sg.amounts {amounts: a};
		prob: Problem prob.commonFactor == true && prob.commonAmountIE
			{commonAmountIE: s};
		ie: TextInput ie.name == s;
		sai: StudentValues sai.selection == s || sai.selection == "hint" {input: i};
	}
	then {
		console.log("------");
		console.log(i);
		// console.log("use commonfactor");
		
		if (checkSAI({selection: s, action: "UpdateTextField", input: i},

				function(studentSAI) {
					var inputNum = parseInt(studentSAI.input, 10);
					return (inputNum !== 0 && a[0]%inputNum === 0 && a[1]%inputNum === 0);
				}))
		{
			modify(ie, "value", i);
			retract(sg);
			halt();
		}
		assert(new Hint(ch1));
		assert(new Hint(ch2));
		assert(new Hint("Enter '"+gcd(a[0], a[1])+"' in the highlighted input field."));

	}
}


/*
USE-UNIT
If there is a subgoal to determine the common amount
And the problem allows the unit strategy
THEN
Write a common factor of 1 as the common amount
Remove the subgoal
*/

rule useUnit {
	when {
		sg : CommonAmountSubgoal sg.amounts {amounts: a};
		prob: Problem prob.unit == true && prob.commonAmountIE
			{commonAmountIE: s};
		ie: TextInput ie.name == s;
		sai: StudentValues sai.selection == s || sai.selection == "hint" {input: i};
	}
	then {
		console.log("use unit");
		if (checkSAI({selection: s, action: "UpdateTextField", input: 1}))
		{
			modify(ie, "value", 1);
			retract(sg);
			halt();
		}

		assert(new Hint(ch1));
		assert(new Hint(ch2));
		assert(new Hint("Enter " + "1"+ " in the highlighted input field."));
	}
}



/*
DETERMINE-SCALED-COST
IF the common amount has been determined to be N
And the scaled cost for option I has not been determined
And the given amount and cost for option I are A and C, respectively
THEN
Write (N / A) * C as the scaled cost for option I
*/

rule DetermineScaledCost {
	when {
		prob : Problem prob.commonAmountIE {commonAmountIE: comAmt, options: opts};
		comAmtIE : TextInput comAmtIE.name == comAmt && comAmtIE.value {value: n};
		opt : Option opt.name in opts && opt.givenValues && opt.interfaceElements
			{givenValues: givens, interfaceElements: IEs};
		normCostIE : TextInput normCostIE.name == IEs[2] && !normCostIE.value;
	}
	then {
		var normCost = (n/givens[0])*givens[1];
		if (!Number.isInteger(normCost)) { normCost = normCost.toFixed(2); }
		if (checkSAI({selection: IEs[2], action: "UpdateTextField",input: normCost},

				//-------- comments ---------
				// Here we are using a custom comparison function in the call to checkSAI
				//     to deal with round off. The rule-generated value (in normCost)
				//     is rounded of to two positions. See code above.
				//  The student-generated value (in stuSAI.input) is converted from
				//     string to Float and then rounded off as well.
				//-------- end comments ---------

					  function(stuSAI, sysSAI) {
						var ret = (( stuSAI.selection ===  sysSAI.selection  )
								&& ( stuSAI.action ===  sysSAI.action )
								&& ((parseFloat(stuSAI.input, 10).toFixed(2)) == 
							 			sysSAI.input));
						return ret; })) {
			modify(normCostIE, "value", normCost);
			halt();
		}
		if (multiple && !unit && !factor) {
			if (opt.name == "option1") {
				assert(new Hint(o1cch1p1 + comAmtIE.value + o1cch1p2));
				assert(new Hint(o1cch2p1 + comAmtIE.value / 2 + o1cch2p2 + comAmtIE.value + o1cch2p3));
			} else {
				assert(new Hint(o2cch1p1 + comAmtIE.value + o2cch1p2));
				assert(new Hint(o2cch2p1 + comAmtIE.value / 4 + o2cch2p2 + comAmtIE.value + o2cch2p3));	
			}
		} else if (!multiple && unit && !factor) {
			if (opt.name == "option1") {
				assert(new Hint(o1cch1p1));
				assert(new Hint(o1cch2p1));
			} else {
				assert(new Hint(o2cch1p1));
				assert(new Hint(o2cch2p1));	
			}
		} else if (!multiple && !unit && factor) {
			if (opt.name == "option1") {
				assert(new Hint(o1cch1p1 + comAmtIE.value + o1cch1p2));
				assert(new Hint(o1cch2p1 + 15 / comAmtIE.value + o1cch2p2 + comAmtIE.value + o1cch2p3));
			} else {
				assert(new Hint(o2cch1p1 + comAmtIE.value + o2cch1p2));
				assert(new Hint(o2cch2p1 + 30 / comAmtIE.value  + o2cch2p2 + comAmtIE.value + o2cch2p3));	
			}
		} else {
			console.log("whats common: "+ comAmtIE.value);
			console.log("whats given: "+ givens[0]);
			console.log("whats given: "+ givens[0] / comAmtIE.value);
			if (comAmtIE.value == 1) {
				assert(new Hint("How long does it take for this person to drive 1 mile?"));
			} else {
				assert(new Hint("How long does it take for this person to drive " + comAmtIE.value + " mile?"));
			}
		}
		assert(new Hint("Enter "+normCost+" in the highlighted input."));
	}
}


/*
COMPARE
IF are problem deals with two options, I1 and I2 (in any order)
And I1 and I2 are not the  same option
And the scaled cost for option I1 has been determined to be N1
And the scaled cost for option I2 has been determined to be N2
And N1 is better than N2 (i.e., more is better and N1 > N2, or more
is not better and N1 < N2)
And the radio button for option I1 has not been clicked
THEN
Click on the radio button for option I1
*/

rule Compare {
	when {
		prob : Problem {moreIsBetter: more, options: opts, commonAmountIE: comAmt};
		opt1 : Option opt1.name in opts && opt1.interfaceElements {interfaceElements: IEs1};
		opt2 : Option opt2.name in opts && opt2 != opt1 && opt2.interfaceElements
				{interfaceElements: IEs2};
			// these 2 constraints will have 2 matches - we need to consider both,
			//    because we do not know in advance which option has the better value
			// eventually, after all constraints have been met, the option bound to opt1
			//    will be the one with the better value
		n1 : TextInput n1.name == IEs1[2] && n1.value {value : nv1};
		radioInput1 : RadioButton radioInput1.name == IEs1[3] && !radioInput1.value
			{group: radioGroupName, input: inp};
		n2 : TextInput n2.name == IEs2[2] &&
					(((greaterThan(nv1, n2.value)) && more == true) ||
					 ((greaterThan(n2.value, nv1)) && more == false));
		f1 : TextInput f1.name == "finalAnswer" && !f1.value;
	}
	then {
		console.log("sad");
		if (checkSAI({selection: radioGroupName, action: "UpdateRadioButton", input: inp})) {
			modify(radioInput1, "value", inp);
			assert(new TextInput("finish", true));
			halt();
		}

		assert(new Hint(fhp1));
		assert(new Hint("Click the radio button for "+opt1.name+"."));
	}
}


/*
DONE
IF a radio button has been (correctly) clicked
THEN
Click Done
*/

// RULE done
rule clickDone {
  when {
    // Conditions for completed problem
	prob : Problem;
    f1 : TextInput f1.name == "finish" && f1.value;
  }

  then {
    let predictedSAI = {
           selection: "done",
           action: "ButtonPressed",
           input: "don't_care"
    };
    console.log("testing2");
    if (checkSAI(predictedSAI)) {
        console.log("testing1");
        modify(prob, "done", true);
        halt();
    } else {
        console.log("testing3");
        backtrack();
    }
  }
}